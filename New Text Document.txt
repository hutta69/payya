--RPC--
touch circle.x
code .

struct circleparameter {
    float radius ;
};

struct circleresult {
    float area ;
    float diameter ;
    float circumferece ;
} ;

program CIRCLE_PROGR {
    version CIRCLE_VER {
        circleresult CALC (circleparameter) = 1 ; 
    } = 1 ;
} = 0x12345678 ;

rpcgen -a -C circle.x

_client.c

above call failed

after #endif /* DEBUG */

printf ("enter radius") ;
scanf ("%f" , &calc_1_arg.radius);

after call failed

printf ("Radius : %.2f\n",calc_1_arg.radius);
printf ("Area : %.2f\n" ,result_1 -> area);
printf ("Diameter : %2f\n" ,result_1 -> diameter);
printf ("circumferece : %.2f\n" ,result_1 -> circumferece); 

_server.c

	const float PI = 3.14 ;
	float radius = argp ->radius ;

	result.area = PI * radius * radius ;
	result.diameter  = 2 * radius ;
	result.circumferece = 2 * PI * radius; 

sudo make -f Makefile.circle
sudo ./circle_server
sudo ./circle_client localhost

--RMI--

create 4 java files



javac *.java
rmiregistry 1099
java Server 
java Client

--MPI--

first make file.c file
mpicc file.c -o name
mpirun -np (no of process) ./name

....RPC.........

factorial---

struct num{
	int x;
};

program FACTORIAL{
	version FACOVER{
	   int fac(num)=1;
	}=1;
}=0x12345678;

*->client

#endif	/* DEBUG */

	printf("Enter the number: ");
	scanf("%d",&fac_1_arg.x);

	result_1 = fac_1(&fac_1_arg, clnt);
	if (result_1 == (int *) NULL) {
		clnt_perror (clnt, "call failed");
	}
printf("Factorial Value: %d\n",*result_1);

*->server


    int facv=1;
	for (int i = 1; i <=argp->x; ++i)
	{
		facv=facv*i;
	}

swap----

struct num{
	int a;
	int b;
};

program swap{
	version swapover{
	   int swapnum(num)=1;
	   int swapnum1(num)=2;
	}=1;
}=0x12345678;

*-->client
int num1,num2;

	printf("Enter the first number: ");
	scanf("%d",&swapnum_1_arg.a);

	printf("Enter the second number: ");
	scanf("%d",&swapnum1_1_arg.b);

	num1=swapnum1_1_arg.a=swapnum_1_arg.a;
	num2=swapnum1_1_arg.b=swapnum_1_arg.b;


	clnt = clnt_create (host, swap, swapover, "udp");
	if (clnt == NULL) {
		clnt_pcreateerror (host);
		exit (1);
	}

	printf("Before Swapping Numbers:\n");
	printf("A = %d\n",num1);
	printf("B = %d\n\n",num2);

	printf("After Swapping Numbers:\n");
	printf("A = %d \n",*result_1);
	printf("B = %d",*result_2);

*->server

	int temp=argp->a;
	argp->a=argp->b;
	argp->b=argp->a;

	result=argp->a;
	---------
	result=argp->b;

---circle--------

struct values{
	float r;
	float pi;
	char op;
};
program CIRCLE {
	version VERCIRCLE{
	float AREA(values) = 1;
	float DIAMETER(values) = 2;
	float CIRCUMFERENCE(values) = 3;
	
	} = 4;


} = 0x23456789;

**cilent**

if(op == 'A'){

area_4_arg.r = n1;
area_4_arg.pi = n2;


	result_1 = area_4(&area_4_arg, clnt);
	
	return *result_1;



}else if(op == 'D'){
  
diameter_4_arg.r = n1;
diameter_4_arg.pi = n2;

	result_2 = diameter_4(&diameter_4_arg, clnt);

	return *result_2;	



}else if(op == 'C'){

	circumference_4_arg.r = n1;
	circumference_4_arg.pi = n2;

	result_3 = circumference_4(&circumference_4_arg, clnt);
	
	return *result_3;
}

--
int
main (int argc, char *argv[])
{
	char *host,op;
	float n1,n2,result;

	printf("enter radias: ");
	scanf("%f",&n1);
	printf("enter pi value:");
	scanf("%f",&n2);
	printf("enter oparetor A , D , C :");
	scanf("%s",&op);

	
	host = argv[1];
	result = circle_4 (host,n1,n2,op);

printf("value is: %.2f",result);

exit (0);
}

**server**

static float  result;

	result = argp->pi * argp->r * argp->r;
	
	return &result;
---
	static float  result;

	result = 2 * argp->r;

	return &result;
---

	static float  result;

	result = 2 * argp->pi * argp->r;

	return &result;

----calculator---

struct numbs{
	int x;
	int y;
	int z;
};

program CALPRO{
	version CALVER{
		int cal(numbs)=1;
}=1;
}=0x2fffffff;

...client
clnt = clnt_create (host, CALPRO, CALVER, "udp");
	if (clnt == NULL) {
		clnt_pcreateerror (host);
		exit (1);
	}
	
	printf("enter 1st Num - ");
	scanf("%d",&cal_1_arg.x);
	
	printf("enter 1st Num - ");
	scanf("%d",&cal_1_arg.y);
	
	
	printf("1 - Addition\n");
	printf("2 - Subscription\n");
	printf("3 - Multiplication\n");
	printf("4 - Divition \n\n");
	printf("enter operent - ");
	scanf("%d",&cal_1_arg.z);

result_1 = cal_1(&cal_1_arg, clnt);
	if (result_1 == (int *) NULL) {
		clnt_perror (clnt, "call failed");
	}
	
	else{
		printf("result is - %d ", *result_1);
	}
	

.....server

#include "cal.h"

int *
cal_1_svc(numbs *argp, struct svc_req *rqstp)
{
	static int  result;

	if (argp->z == 1){
		result = argp->x + argp->y;
	}
	else if(argp->z == 2){
		result = argp->x - argp->y;
	}
	else if(argp->z == 3){
		result = argp->x * argp->y;
	}
	else if(argp->z == 4){
		result = argp->x / argp->y;
	}

	return &result;
}



javac sumIntf.java
javac sumImpl.java
rmic sumImpl
javac sumserver.java
javac sumclient.java
rmiregistry &
java sumserver
new teminal -> java sumclient

mpicc sum.c -o sum
mpirun -np 2 ./sum


....RMI........

Square number..

squareinterface.java

import java.rmi.*; 
public interface SquareInterface extends Remote { 
public int calculateSquare(int n) throws RemoteException; 
} 

square.java

import java.rmi.*; 
import java.rmi.server.*; 
public class Square extends UnicastRemoteObject implements SquareInterface { 
public Square() throws RemoteException { 
super(); 
} 
public int calculateSquare(int n) throws RemoteException { 
return n * n; 
} 

SquareServer.java

import java.rmi.*; 
 
public class SquareServer { 
public static void main(String args[]) { 
try { 
Square obj = new Square(); 
Naming.rebind("SquareService", obj); 
System.out.println("Square Server is ready."); 
} catch (Exception e) { 
System.out.println("Server Error: " + e.getMessage()); 
} 
} 
} 

SquareClient.java

import java.rmi.*; 
public class SquareClient { 
public static void main(String args[]) { 
try { 
// Check if user provided a number in command line 
if (args.length < 1) { 
System.out.println("Please provide a number."); 
return; 
}
int number = Integer.parseInt(args[0]); 
SquareInterface stub = (SquareInterface) Naming.lookup("rmi://localhost/SquareService"); 
int result = stub.calculateSquare(number); 
System.out.println("The Square of " + number + " is: " + result); 
} catch (Exception e) { 
System.out.println("Client Error: " + e.getMessage()); 
} 
} 
} 

Monthly salary calculation.....

Employeeinterface.java

import java.rmi.*; 
 
public interface EmployeeInterface extends Remote { 
// Method to calculate net salary 
public double calculateNetSalary(double basicSalary) throws RemoteException; 
}

Employee.java

import java.rmi.*; 
import java.rmi.server.*; 
public class Employee extends UnicastRemoteObject implements 
EmployeeInterface { 
public Employee() throws RemoteException { 
super(); 
} 
public double calculateNetSalary(double basicSalary) throws 
RemoteException { 
double allowance = basicSalary * 0.20; 
double deduction = basicSalary * 0.10; 
double netSalary = basicSalary + allowance - deduction; 
return netSalary; 
} 
}

 EmployeeServer.java 

import java.rmi.*; 

public class EmployeeServer { 
public static void main(String args[]) { 
try { 
Employee obj = new Employee(); 
Naming.rebind("SalaryService", obj); 
System.out.println("Employee Server is running..."); 
} catch (Exception e) { 
System.out.println("Server Error: " + e.getMessage()); 
} 
} 
}

EmployeeClient.java

import java.rmi.*; 
import java.util.Scanner; 
public class EmployeeClient { 
public static void main(String args[]) { 
try { 
Scanner sc = new Scanner(System.in); 
System.out.println("Enter Basic Salary: "); 
double basic = sc.nextDouble();

// Connect to server 
EmployeeInterface stub = (EmployeeInterface) 
Naming.lookup("rmi://localhost/SalaryService"); 
// Get result 
double netSalary = stub.calculateNetSalary(basic); 
System.out.println("Net Salary is: " + netSalary); 
} catch (Exception e) { 
System.out.println("Client Error: " + e.getMessage()); 
} 
} 
} 


............MPI..........

fahrenhite , celisius.........

#include <stdio.h>
#include <mpi.h>

int main(int argc, char *argv[]) {
    int rank;
    float celsius, fahrenheit, kelvin;
    float temps[3];

    MPI_Init(&argc, &argv);
    MPI_Comm_rank(MPI_COMM_WORLD, &rank);

    // Process 0: Input Celsius
    if (rank == 0) {
        printf("Enter temperature in Celsius: ");
        scanf("%f", &celsius);

        MPI_Send(&celsius, 1, MPI_FLOAT, 1, 0, MPI_COMM_WORLD);
    }

    // Process 1: Celsius -> Fahrenheit
    else if (rank == 1) {
        MPI_Recv(&celsius, 1, MPI_FLOAT, 0, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);

        fahrenheit = (celsius * 9 / 5) + 32;
        MPI_Send(&fahrenheit, 1, MPI_FLOAT, 2, 0, MPI_COMM_WORLD);
    }

    // Process 2: Fahrenheit -> Kelvin
    else if (rank == 2) {
        MPI_Recv(&fahrenheit, 1, MPI_FLOAT, 1, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);

        kelvin = (fahrenheit - 32) * 5 / 9 + 273.15;
        MPI_Send(&kelvin, 1, MPI_FLOAT, 3, 0, MPI_COMM_WORLD);
    }

    // Process 3: Validate and Average
    else if (rank == 3) {
        // Receive Kelvin
        MPI_Recv(&kelvin, 1, MPI_FLOAT, 2, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);

        // Reconstruct values
        celsius = kelvin - 273.15;
        fahrenheit = (celsius * 9 / 5) + 32;

        // Validation: Kelvin must be >= 0
        if (kelvin < 0) {
            printf(" Error: Physically impossible temperature (below absolute zero)\n");
        } else {
            float avg = (celsius + fahrenheit + kelvin) / 3;
            printf("\nCelsius: %.2f\nFahrenheit: %.2f\nKelvin: %.2f\n", celsius, fahrenheit, kelvin);
            printf("Average Temperature = %.2f\n", avg);
        }
    }

    MPI_Finalize();
    return 0;







